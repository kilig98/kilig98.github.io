<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java总结2, kilig-blog">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java总结2 | kilig-blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.0.2"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">kilig-blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">kilig-blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java总结2</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%80%BB%E7%BB%93/">
                                <span class="chip bg-color">总结</span>
                            </a>
                        
                            <a href="/tags/JAVA/">
                                <span class="chip bg-color">JAVA</span>
                            </a>
                        
                            <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">笔记</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JAVA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" class="post-category">
                                JAVA基本知识
                            </a>
                        
                            <a href="/categories/JAVA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/JAVA%E5%AD%A6%E4%B9%A0/" class="post-category">
                                JAVA学习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-08-24
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.2k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="IO，NIO，AIO"><a href="#IO，NIO，AIO" class="headerlink" title="IO，NIO，AIO"></a>IO，NIO，AIO</h1><p><strong>IO介绍</strong></p>
<p>​        IO是基于流模型出现的输入输出流，比如操作文件时用输入输出流读取文件和写入文件。</p>
<p>​        传统IO是BIO（Block-IO）传统阻塞IO。</p>
<ul>
<li>字节流：InputStream，OutputStream</li>
<li>字符流：Reader，Writer</li>
</ul>
<p><img src="/2020/08/24/Java%E6%80%BB%E7%BB%932/image-20200824125213180.png" alt="java流"></p>
<ol>
<li>Writer的使用</li>
</ol>
<pre class=" language-java"><code class="language-java">Writer writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWriter</span><span class="token punctuation">(</span><span class="token string">"D:\\培训\\test.txt"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//true表示追加，false表示覆盖</span>
writer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"方芳芳"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ol start="2">
<li>Reader的使用</li>
</ol>
<pre class=" language-java"><code class="language-java">Reader reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"D:\\\\培训\\\\test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
BufferedReader bufferedReader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">;</span>
String str <span class="token operator">=</span> null<span class="token punctuation">;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>str <span class="token operator">=</span> bufferedReader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>
<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
bufferedReader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ol start="3">
<li>InputStream的使用</li>
</ol>
<pre class=" language-java"><code class="language-java">InputStream inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:\\培训\\test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>inputStream<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ol start="4">
<li>OutputStream的使用</li>
</ol>
<pre class=" language-java"><code class="language-java">OutputStream outputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\培训\\test.txt"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"老王"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
outputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>NIO介绍</strong></p>
<p>​        Java1.4出现了java.nio包，NIO（Non-Blocking IO）同步非阻塞IO。它提供了Channel、Selector、Buffer等概念，可以实现多路复用和同步非阻塞IO操作，提高了IO操作的性能。</p>
<table>
<thead>
<tr>
<th align="center">组合方       式</th>
<th>性能分析</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同步阻塞</td>
<td>最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态</td>
</tr>
<tr>
<td align="center">同步非阻塞</td>
<td>提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O  是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。 这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O  性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上</td>
</tr>
<tr>
<td align="center">异步阻塞</td>
<td>这种方式在分布式数据库中经常用到。例如，在往一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其他机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O；异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况</td>
</tr>
<tr>
<td align="center">异步非阻塞</td>
<td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O  组合方式。例如，Cassandra 的 Gossip  通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O  用这个方式性能能达到最高</td>
</tr>
</tbody></table>
<p><strong>AIO介绍</strong></p>
<p>​        AIO是NIO的升级，称为异步非阻塞IO，异步IO的操作基于事件和回调机制。</p>
<hr>
<p><strong>IO，NIO，AIO的区别？</strong></p>
<ul>
<li>BIO 就是传统的 java.io  包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。它的优点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li>
<li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，因此人们叫它  AIO（Asynchronous IO），异步 IO  是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
<p>​      简单来说 BIO 就是传统 IO 包，产生的最早；NIO 是对 BIO 的改进提供了多路复用的同步非阻塞 IO，而 AIO 是 NIO 的升级，提供了异步非阻塞 IO。</p>
<p><strong>文件的读写</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 读取文件</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"d:\\io.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 写入文件</span>
Files<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"d:\\io.txt"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"追加内容"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>APPEND<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>Files的常见操作？</strong></p>
<p>​        Files是Java1.7提供的，使得文件和文件夹的操作更加方便。常用方法如下：</p>
<ul>
<li>Files. exists()：检测文件路径是否存在</li>
<li>Files. createFile()：创建文件</li>
<li>Files. createDirectory()：创建文件夹</li>
<li>Files. delete()：删除一个文件或目录</li>
<li>Files. copy()：复制文件</li>
<li>Files. move()：移动文件</li>
<li>Files. size()：查看文件个数</li>
<li>Files. read()：读取文件</li>
<li>Files. write()：写入文件</li>
</ul>
<p><strong>不定项选择：为了提高读写性能，可以采用什么流？</strong></p>
<p> A：InputStream<br> B：DataInputStream<br> C：BufferedReader<br> D：BufferedInputStream<br> E：OutputStream<br> F：BufferedOutputStream</p>
<p>答：D、F</p>
<p>​        题目解析：BufferedInputStream  是一种带缓存区的输入流，在读取字节数据时可以从底层流中一次性读取多个字节到缓存区，而不必每次都调用系统底层；同理，BufferedOutputStream  也是一种带缓冲区的输出流，通过缓冲区输出流，应用程序先把字节写入缓冲区，缓存区满后再调用操作系统底层，从而提高系统性能，而不必每次都去调用系统底层方法。</p>
<p><strong>FileInputStream和BufferedInputStream的区别？</strong></p>
<p>​        FileInputStream读小文件性能更好，BufferedInputStream进行大文件操作更有优势。</p>
<h1 id="反射和JDK动态代理技术"><a href="#反射和JDK动态代理技术" class="headerlink" title="反射和JDK动态代理技术"></a>反射和JDK动态代理技术</h1><p>​        <strong>反射</strong></p>
<p>​        通过反射，可以在程序运行期间获取，检测，调用对象的属性和方法。</p>
<p>反射的使用场景：</p>
<ol>
<li>框架</li>
<li>数据库连接池</li>
</ol>
<p>​        反射获取调用类可以通过 Class.forName()，反射获取类实例要通过 newInstance()，相当于  new 一个新对象，反射获取方法要通过 getMethod()，获取到类方法之后使用  invoke() 对类方法进行调用。如果是类方法为私有方法的话，则需要通过  setAccessible(true) 来修改方法的访问限制，以上的这些操作就是反射的基本使用。</p>
<p>​        <strong>动态代理技术</strong></p>
<p>​        动态代理技术可以理解为本可以自己做的事情，交给别人去做。</p>
<p>动态代理的使用场景：</p>
<ol>
<li>面向切面编程AOP</li>
<li>封装一些AOP调用，也可以通过代理实现一个全局拦截器。</li>
</ol>
<p><strong>JDK动态代理技术</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The dog is eating"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The cat is eating"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// JDK 代理类</span>
<span class="token keyword">class</span> <span class="token class-name">AnimalProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Object target<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 代理对象</span>
    <span class="token keyword">public</span> Object <span class="token function">getInstance</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 取得代理对象</span>
        <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 方法调用</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// JDK 动态代理调用</span>
    AnimalProxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnimalProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Animal dogProxy <span class="token operator">=</span> <span class="token punctuation">(</span>Animal<span class="token punctuation">)</span> proxy<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dogProxy<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>JKD动态代理技术只能代理实现接口的类。</p>
<p><strong>cglib字节码增强技术</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Panda</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The panda is eating"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">CglibProxy</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> Object target<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 代理对象</span>
    <span class="token keyword">public</span> Object <span class="token function">getInstance</span><span class="token punctuation">(</span>Object target<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
        Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 设置父类为实例类</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 回调方法</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 创建代理对象</span>
        <span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object result <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 执行方法调用</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// cglib 动态代理调用</span>
    CglibProxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CglibProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Panda panda <span class="token operator">=</span> <span class="token punctuation">(</span>Panda<span class="token punctuation">)</span>proxy<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Panda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    panda<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>​        由以上代码可以知道，cglib 的调用通过实现 MethodInterceptor 接口的 intercept 方法，调用  invokeSuper 进行动态代理的。它可以直接对普通类进行动态代理，并不需要像 JDK 代理那样，需要通过接口来完成，值得一提的是  Spring 的动态代理也是通过 cglib 实现的。</p>
<p>​        <strong>注意</strong>：cglib 底层是通过子类继承被代理对象的方式实现动态代理的，因此代理类不能是最终类（final），否则就会报错 java.lang.IllegalArgumentException: Cannot subclass final class xxx。</p>
<hr>
<p><strong>动态代理解决了什么问题？</strong></p>
<p>​        实现代码之间的解耦。</p>
<p><strong>动态代理技术和反射机制的联系？</strong></p>
<p>​        反射机制可以实现动态代理技术，但是动态代理技术不仅可以通过反射机制实现，也可以通过cglib字节码增强技术，ASM（一个短小精悍的字节码操作框架）等实现。</p>
<p><strong>以下描述错误的是？</strong></p>
<p>A：cglib 的性能更高<br>B：Spring 中有使用 cglib 来实现动态代理<br>C：Spring 中有使用 JDK 原生的动态代理<br>D：JDK 原生动态代理性能更高</p>
<p>选D。  JDK动态代理技术的性能比字节码增强技术的性能低，Spring动态代理的实现方式有两种：JDK动态代理技术和字节码增强技术。</p>
<p><strong>cglib可以代理所有类吗？</strong></p>
<p>​        cglib不能代理final修饰的类，因为cglib需要继承被代理类。</p>
<p><strong>JDK动态代理技术和cglib的区别？</strong></p>
<p>​        JDK动态代理技术：被代理类必须实现接口，不需要任何依赖，可以平滑的支持JDK版本的升级。</p>
<p>​        cglib：被代理类不需要实现接口，需要添加依赖，性能更高。</p>
<p><strong>为什么JDK动态代理技术必须实现接口？</strong></p>
<p>​        因为JDK动态代理技术的实现方法newProxyInstance()里有两个参数，一个是类加载器，另一个是实现的接口列表，所以必须实现接口才可以。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>​        <strong>线程</strong></p>
<p>​        线程是程序运行的执行单元，依托于进程存在。一个进程中可以包含多个线程，多线程可以共享一块内存空间和一组系统资源，因此线程之间的切换更加节省资源，更加轻量化。</p>
<p>​        <strong>进程</strong></p>
<p>​        进程是程序的一次动态执行，是系统进行资源分配和调度的基本单位，是操作系统运行的基础，通常每一个进程都拥有自己独立的内存空间和系统资源。简单来说，进程可以被当做是一个正在运行的程序。</p>
<p><strong>为什么需要线程？</strong></p>
<p>​        因为程序的运行必须依靠进程，线程又是进程的基本执行单元。</p>
<p><strong>多线程？</strong></p>
<p>​        提高程序的执行性能。</p>
<p><strong>线程的创建？</strong></p>
<ol>
<li>继承Thread，重写run()方法</li>
<li>实现Runnable，实现run()方法</li>
<li>实现Callable，实现run()方法</li>
</ol>
<pre class=" language-java"><code class="language-java">Callable<span class="token operator">:</span>
        MyTaskByCallable task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTaskByCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        FutureTask<span class="token operator">&lt;</span>String<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        FutureTask<span class="token operator">&lt;</span>String<span class="token operator">></span> futureTask1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>wait()</strong></p>
<p>​        使用wait()实现线程等待。</p>
<p>​        当使用wait()时，必须持有当前对象的锁，否则会返回异常。</p>
<p><strong>join()</strong></p>
<p>​        当前线程执行完成之后才能继续执行下面的语句。</p>
<p><strong>yiled()</strong></p>
<p>​        线程让步，交出CPU的执行权。yield 方法是让同优先级的线程有执行的机会，但不能保证自己会从正在运行的状态迅速转换到可运行的状态。</p>
<p><strong>interrupted()</strong></p>
<p>​        中断线程</p>
<p><strong>线程优先级</strong></p>
<p>​        setPriority()设置线程优先级，1—10。</p>
<p><strong>死锁</strong></p>
<p><img src="/2020/08/24/Java%E6%80%BB%E7%BB%932/image-20200824173526019.png" alt="死锁"></p>
<p>​        死锁是指两个或两个以上的线程，由于竞争资源或者由于彼此通信造成的一种阻塞现象，如果无外力介入，它们都无法推进下去。</p>
<p>​        线程A独占锁1，线程B独占锁2，当线程A尝试去获取锁2，线程B尝试去获取锁1时，由于两个线程各自占有对方的锁，就会一直阻塞下去。</p>
<hr>
<p><strong>线程和进程的区别？</strong></p>
<p>​        从本质上来说，线程是进程的实际执行单元，一个程序至少有一个进程，一个进程至少有一个线程，它们的区别主要体现在以下几个方面：</p>
<ul>
<li>进程间是独立的，不能共享内存空间和上下文，而线程可以；</li>
<li>进程是程序的一次执行，线程是进程中执行的一段程序片段；</li>
<li>线程占用的资源比进程少。</li>
</ul>
<p><strong>线程的常用方法？</strong></p>
<ul>
<li>currentThread()：返回当前正在执行的线程引用</li>
<li>getName()：返回此线程的名称</li>
<li>setPriority()/getPriority()：设置和返回此线程的优先级</li>
<li>isAlive()：检测此线程是否处于活动状态，活动状态指的是程序处于正在运行或准备运行的状态</li>
<li>sleep()：使线程休眠</li>
<li>join()：等待线程执行完成</li>
<li>yield()：让同优先级的线程有执行的机会，但不能保证自己会从正在运行的状态迅速转换到可运行的状态</li>
<li>interrupted()：是线程处于中断的状态，但不能真正中断线程</li>
</ul>
<p><strong>wait()和sleep()的区别？</strong></p>
<p>​        wait() 和 sleep() 的区别主要体现在以下三个方面。</p>
<ul>
<li>存在类的不同：sleep() 来自 Thread，wait() 来自 Object。</li>
<li>释放锁：sleep() 不释放锁；wait() 释放锁。</li>
<li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll() 直接唤醒。</li>
</ul>
<p><strong>守护线程：</strong></p>
<p>​        守护线程的优先级是最低的，它通常为其他线程提供服务，通过setDaemon方法设置。例如JVM中的垃圾回线程。</p>
<p><strong>线程的状态？</strong></p>
<ul>
<li>NEW：尚未启动</li>
<li>RUNNABLE：正在执行中</li>
<li>BLOCKED：阻塞（被同步锁或者 IO 锁阻塞）</li>
<li>WAITING：永久等待状态</li>
<li>TIMED_WAITING：等待指定的时间重新被唤醒的状态</li>
<li>TERMINATED：执行完成</li>
</ul>
<p><strong>start()和run()的区别？</strong></p>
<p>​        start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<p><strong>产生死锁的条件？</strong></p>
<ul>
<li>互斥条件：一个资源每次只能被一个线程使用；</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>不剥夺条件：线程已获得的资源，在末使用完之前，不能强行剥夺；</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系；</li>
</ul>
<p><strong>预防死锁？</strong></p>
<ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit) 的方法 (ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁；</li>
<li>尽量使用 Java. util. concurrent 并发类代替自己手写锁；</li>
<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁；</li>
<li>尽量减少同步的代码块。</li>
</ul>
<p><strong>thread.wait()和thread.wait(0)</strong></p>
<p>​        两个方法效果相同，但是wait()方法内部是调用wait(0)方法。wait()方法表示进入等待状态，让出当前的锁和CPU资源，并且只有其他线程执行notify()和notifyall()方法才能唤醒该线程。</p>
<p><strong>线程的调度策略？</strong></p>
<p>​        线程调度器选择优先级最高的线程运行，但是如果发生以下情况，就会终止线程的运行：</p>
<ul>
<li>线程体中调用了 yield() 方法，让出了对 CPU 的占用权；</li>
<li>线程体中调用了 sleep() 方法，使线程进入睡眠状态；</li>
<li>线程由于 I/O 操作而受阻塞；</li>
<li>另一个更高优先级的线程出现；</li>
<li>在支持时间片的系统中，该线程的时间片用完。</li>
</ul>
<p><strong>总结</strong></p>
<p>​        程序的运行依靠的是进程，而进程的执行依靠的是多个线程，多线程之间可以共享一块内存和一组系统资源，而多进程间通常是相互独立的。线程的创建有三种方式：继承 Thread 重写 run 方法，实现 Runnable 或 Callable 接口，其中 Callable  可以允许线程的执行有返回值，JDK 8 中也可以使用 Lambda 来更加方便的使用线程，线程是有优先级的，优先级从 1-10  ，数字越大优先级越高，也越早被执行。如果两个线程各自拥有一把锁的同时，又同时等待获取对方的锁，就会造成死锁。可以降低锁的粒度或减少同步代码块的范围或使用 Java 提供的安全类，来防止死锁的产生。</p>
<h1 id="线程池之ThreadPoolExecutor"><a href="#线程池之ThreadPoolExecutor" class="headerlink" title="线程池之ThreadPoolExecutor"></a>线程池之ThreadPoolExecutor</h1><p>​        线程池：把一个或多个线程通过统一的方式调度和重复使用的技术，减少性能的损耗。</p>
<p><strong>为什么使用线程池？</strong></p>
<ul>
<li><p>可重复使用已有线程，避免对象创建、消亡和过度切换的性能开销。</p>
</li>
<li><p>避免创建大量同类线程所导致的资源过度竞争和内存溢出的问题。</p>
</li>
<li><p>支持更多功能，比如延迟任务线程池（newScheduledThreadPool）和缓存线程池（newCachedThreadPool）等。</p>
<p>​    在Java中，线程池的概念是Executor这个接口，具体实现类为ThreadPoolExcutor。</p>
</li>
</ul>
<p><strong>ThreadPoolExecutor的参数？</strong></p>
<ol>
<li><p>int corePoolSize：该线程池中核心线程数的最大值</p>
<p>​    <strong>核心线程：</strong>线程池新建线程的时候，如果当前线程数小于核心线程数，那么会创建核心线程。如果超过corePoolSize，那么会创建非核心线程。核心线程默认情况下会一直存活在线程池中，即使它什么也不做。</p>
<p>​    如果指定allowCoreThreadTimeOut的属性为true，那么核心线程如果闲置状态的话，超过一定时间就会被销毁。</p>
</li>
<li><p>int maximamPoolSize：该线程池中线程总数的最大值。</p>
<p>​    线程总数=核心线程数+非核心线程数</p>
</li>
<li><p>long keepAliveTime：非核心线程的闲置存活时间</p>
<p>​    一个非核心线程，如果闲置超过该时间，该线程就会被销毁。如果allowCoreThreadTimeOut设置为true，那么该时间也会作用在核心线程上。</p>
</li>
<li><p>TimeUnit unit：闲置存活时间的单位</p>
<p>​    TimeUnit是一个枚举类型。微毫秒，微秒，毫秒，s，min，hour，days</p>
</li>
<li><p>BlockingQueue workQueueu：该线程池中的任务队列：维护着等待执行的Runnable对象</p>
<p>​    当所有的核心线程都在运作时，新添加的任务会添加到这个队列，如果队列满了，则新建非核心线程去执行任务。常见的workQueue类型：</p>
<p>​    <strong>SynchronousQueue：</strong>该队列会直接提交收到的任务，所以为了保证线程数不能达到maximumPoolSize，一般会将该属性设置为Integer.MAX_VALUE。</p>
<p>​    <strong>LinkedBlockingQueue：</strong>接受到任务时，先判断核心线程数，创建或者把任务放到队列中，因为该队列是无限大的，所以会导致maximumPoolSize失效。</p>
<p>​    <strong>ArrayBlockingQueue：</strong>可以限定队列的长度，当接受到任务时，判断核心线程数，创建，或者把任务放入队列，如果队列满了，创建非核心线程执行任务，如果队列满了，线程总数也满了，则会发生错误。</p>
<p>​    <strong>DelayQueue：</strong>队列内的元素必须实现Delay接口，所以当一个任务传入队列时，只有达到了指定的时间，才会被执行。</p>
</li>
<li><p>ThreadFactory：为线程池创建一个线程工厂。</p>
</li>
<li><p>rejectedExecutorHandler</p>
<p>​    线程池中任务队列超过最大值的拒绝策略，rejectedExecutorHandler是一个接口，它里面只有一个方法，可以在这个方法中添加超过队列最大值的处理事件。</p>
<p>​    ThreadPoolExecutor中提供了四种默认的拒绝策略：</p>
</li>
</ol>
<ul>
<li>new ThreadPoolExecutor.DiscardPolicy()：丢弃掉该任务，不进行处理</li>
<li>new ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列里最近的一个任务，并执行当前任务</li>
<li>new ThreadPoolExecutor.AbortPolicy()：直接抛出 RejectedExecutionException 异常</li>
<li>new ThreadPoolExecutor.CallerRunsPolicy()：既不抛弃任务也不抛出异常，直接使用主线程来执行此任务</li>
</ul>
<p><strong>向线程池添加任务</strong></p>
<p>​        ThreadPoolExecutor.execute(Runnable task)提交任务</p>
<p><strong>ThreadPoolExecutor的策略</strong></p>
<p>​        当一个任务被添加进线程池时：</p>
<ol>
<li>线程数量未达到核心线程数，创建核心线程执行任务。</li>
<li>达到核心线程数，添加进任务队列。</li>
<li>队列已满，新建线程（非核心线程）执行任务。</li>
<li>队列已满，线程数也满，根据拒绝策略调用逻辑。</li>
</ol>
<p><strong>常见的四种线程池？</strong></p>
<p>​        Java通过Executors提供了四种核心线程池，这四种线程池都是直接或间接配置ThreadPoolExecutor的参数实现的。</p>
<ul>
<li><strong>可缓存线程池CachedThreadPool()</strong></li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>
                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<ol>
<li>没有核心线程，线程数无限制。</li>
<li>在创建任务时，若有空闲线程，直接复用，若无，则创建线程。</li>
<li>闲置状态的线程超过60秒，就会被移除。</li>
</ol>
<ul>
<li><strong>定长线程池FixedThreadPool</strong></li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                  0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<ol>
<li>核心线程数等于总线程数，所以默认情况下，线程不会销毁。</li>
<li>提交了任务，如果有闲置线程，也不会复用，会创建一个新线程。之后会创建线程，添加任务到队列中。</li>
</ol>
<ul>
<li><strong>单线程池SingleThreadPool</strong></li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
                                0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<ol>
<li>有且只有一个线程执行任务。</li>
<li>所有任务按照顺序执行，遵循队列的入队出队规则。</li>
</ol>
<ul>
<li><strong>延时线程池ScheduledThreadPool</strong></li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledExecutorService <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//ScheduledThreadPoolExecutor():public ScheduledThreadPoolExecutor(int corePoolSize) &amp;#123;</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>
          DEFAULT_KEEPALIVE_MILLIS<span class="token punctuation">,</span> MILLISECONDS<span class="token punctuation">,</span>
          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>​        DEFAULT_KEEPALIVE_MILLIS默认为10秒。</p>
<ol>
<li>不仅设置了核心线程数，还设置了最大线程数为Integer.MAX_VALUE。</li>
<li>唯一一个可以延时执行和周期执行任务的线程池。</li>
</ol>
<pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">/*
         * 延时3s后执行任务
         */</span>
        pool4<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*
         * 延时3s后执行任务，当任务开始执行的时候过7s再次执行
         */</span>
        pool4<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*
         * 延时3s后执行任务，当任务结束后，过7s再次执行
         */</span>
        pool4<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><p><strong>单线程延时线程池SingleThreadScheduledExecutor</strong></p>
<p>​    其实就是一个单线程的延时线程池</p>
</li>
<li><p><strong>并行线程池WorkStealingPool</strong></p>
<p>​    Java8新增的线程池，如果不指定任</p>
<p>何参数，则以当前机器处理器个数作为线程个数，此线程池并行处理任务，不保证执行顺序。</p>
</li>
</ul>
<p><strong>ThreadFactory就是一个接口，用来创建线程。</strong></p>
<hr>
<p><strong>submit()和execute()</strong></p>
<ol>
<li>execute()传入的是Runnable，submit()传入的是Callable</li>
<li>execute不能接受返回值，submit可以接收返回值。</li>
</ol>
<p><strong>线程池关闭</strong></p>
<ul>
<li>shutdown()：不会立刻中止线程池，需要等所有任务队列中的任务都执行完才会中止。</li>
<li>shutdownNow()：立刻中止线程池，线程池的状态变为STOP状态，并停止所有正在执行的任务，返回未执行的任务。</li>
</ul>
<p><strong>ThreadPoolExecutor的方法</strong></p>
<ul>
<li>submit()/execute()：执行线程池</li>
<li>shutdown()/shutdownNow()：终止线程池</li>
<li>isShutdown()：判断线程是否终止</li>
<li>getActiveCount()：正在运行的线程数</li>
<li>getCorePoolSize()：获取核心线程数</li>
<li>getMaximumPoolSize()：获取最大线程数</li>
<li>getQueue()：获取线程池中的任务队列</li>
<li>allowCoreThreadTimeOut(boolean)：设置空闲时是否回收核心线程</li>
</ul>
<p><strong>ThreadPoolExecutor VS Executors</strong></p>
<p>​        ThreadPoolExecutor是传统的创建线程池的方式 ，Executors提供了更多类型的线程池类型。但是不推荐使用Executors创建线程池。</p>
<p>​        使用传统的方式可以让读者更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>​        Executors的弊端如下：</p>
<ul>
<li>定长线程池和单线程线程池，它俩的队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM</li>
<li>可缓存线程池和延时线程池，它俩运行创建的线程数量为Integer.MAX_VALUE，可能会创建大量的线程，造成OOM</li>
</ul>
<p><strong>单线程池的意义？</strong></p>
<p>​        单线程线程池提供了队列功能，如果有多个任务会排队执行，可以保证任务执行的顺序性。单线程线程池也可以重复利用已有线程，减低系统创建和销毁线程的性能开销。</p>
<p><strong>总结</strong></p>
<p>​        Executors 可以创建 6 种不同类型的线程池，其中 newFixedThreadPool()  适合执行单位时间内固定的任务数，newCachedThreadPool()  适合短时间内处理大量任务，newSingleThreadExecutor() 和  newSingleThreadScheduledExecutor() 为单线程线程池，而  newSingleThreadScheduledExecutor() 可以执行周期性的任务，是  newScheduledThreadPool(n) 的单线程版本，而 newWorkStealingPool() 为 JDK 8  新增的并发线程池，可以根据当前电脑的 CPU 处理数量生成对比数量的线程池，但它的执行为并发执行不能保证任务的执行顺序。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>​        ThreadLocal用于解决多线程之间的数据隔离问题。也就是说ThreadLocal会为每一个线程创建一个单独的变量副本。</p>
<p><strong>ThreadLocal的应用场景</strong></p>
<ul>
<li><p>用来管理Session，因为每个人的信息是不一样的。</p>
</li>
<li><p>数据库连接，为每一个进程分配一个独立的资源。</p>
</li>
<li><p>还被用于Spring的事务管理器中</p>
</li>
</ul>
<p><strong>ThreadLocal的内存溢出原理</strong></p>
<p>​        ThreadLocal并不存储数据，而是依靠ThreadLocalMap存储数据，ThreadLocalMap中有一个Entry数组，数组通过KV的形式对数据进行存储，其中K就是ThreadLocal本身，V就是要存储的值。</p>
<p>​        如果 ThreadLocal 没有被直接引用（外部强引用），在 GC（垃圾回收）时，由于 ThreadLocalMap 中的 key  是弱引用，所以一定就会被回收，这样一来 ThreadLocalMap 中就会出现 key 为 null 的  Entry，并且没有办法访问这些数据，如果当前线程再迟迟不结束的话，这些 key 为 null 的 Entry 的 value  就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry  -&gt; value 并且永远无法回收，从而造成内存泄漏。</p>
<p>​        每次使用完ThreadLocal之后，调用remove方法移除无用的数据。</p>
<hr>
<p><strong>ThreadLocal为什么是线程安全的？</strong></p>
<p>​        ThreadLocal为每一个维护变量的副本，把共享数据的可见范围限制在同一个线程之内，因此ThreadLocal是线程安全的，每个线程都有属于自己的变量。</p>
<p><strong>如何共享数据？</strong></p>
<p>​        使用ThreadLocal的子类InheritableThreadLocal可以天然的支持多线程间的信息共享。</p>
<p><strong>ThreadLocal和Synchonized的区别？</strong></p>
<p>​        ThreadLocal 和 Synchonized 都用于解决多线程并发访问，防止任务在共享资源上产生冲突，但是 ThreadLocal 与  Synchronized 有本质的区别，Synchronized  用于实现同步机制，是利用锁的机制使变量或代码块在某一时刻只能被一个线程访问，是一种 “以时间换空间” 的方式；而 ThreadLocal  为每一个线程提供了独立的变量副本，这样每个线程的（变量）操作都是相互隔离的，这是一种 “以空间换时间” 的方式。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><strong>synchronized</strong></p>
<p>​        synchronized是Java提供的同步机制，当一个线程正在执行synchronized修饰的代码块时，其他线程只能阻塞等待该线程执行完才能继续执行。</p>
<p>​        synchronized的使用：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 修饰代码块</span>
<span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// do something</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 修饰方法</span>
<span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// do something</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre>
<p>​        实现原理：</p>
<p>​        本质是通过进入和退出的Monitor对象来实现线程安全的。</p>
<p>​        JVM采用monitorenter和monitorexit两个指令实现同步，一个加锁，一个释放锁。</p>
<p><strong>ReentrantLock使用</strong></p>
<pre class=" language-java"><code class="language-java">Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>尝试获取锁</strong></p>
<pre class=" language-java"><code class="language-java">lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回Boolean</span>
lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//尝试一段时间内获取锁</span></code></pre>
<p><strong>ReentrantLock的注意事项</strong></p>
<p>​        使用Lock必须记得释放锁，不然该锁会被永久占用。</p>
<hr>
<p><strong>ReentrantLock的常用方法</strong></p>
<ul>
<li>lock()：用于获取锁</li>
<li>unlock()：用于释放锁</li>
<li>tryLock()：尝试获取锁</li>
<li>getHoldCount()：查询当前线程执行 lock() 方法的次数</li>
<li>getQueueLength()：返回正在排队等待获取此锁的线程数</li>
<li>isFair()：该锁是否为公平锁</li>
</ul>
<p><strong>ReentrantLock的优势</strong></p>
<p>​        ReentrantLock具备非阻塞方式获取锁的特性，使用tryLock()方法，使用tryLock(Time,Unit)方法还可以获取一段时间内的锁。ReentrantLock还可以中断获得的锁，使用lockInterruptibly()方法，当获取锁之后，如果线程被中断，则会抛出异常并释放当前获得的锁。</p>
<p><strong>创建公平锁</strong></p>
<p>​        new ReentrantLock(true)</p>
<p><strong>公平锁和非公平锁</strong></p>
<p>​        公平锁指线程获取锁是按照加锁顺序来的，非公平锁指强锁机制，先lock()的线程不一定先获取锁。</p>
<p><strong>ReentrantLock 中 lock() 和 lockInterruptibly() 有什么区别？</strong></p>
<p>​        lock() 和 lockInterruptibly() 的区别在于获取线程的途中如果所在的线程中断，lock() 会忽略异常继续等待获取线程，而 lockInterruptibly() 则会抛出 InterruptedException 异常。</p>
<p><strong>synchronized和ReentrantLock的区别</strong></p>
<ul>
<li><p>ReentrantLock使用起来比较灵活，但是必须有释放锁的配合动作。</p>
</li>
<li><p>ReentrantLock必须手动加锁，释放锁。synchronized不需要手动开启和释放锁。</p>
</li>
<li><p>ReentrantLock只适用于代码块锁，而synchronized可用于修饰方法，代码块等；</p>
</li>
<li><p>ReentrantLock的性能略高于synchronized。</p>
</li>
</ul>
<p><strong>synchornized如何实现锁升级？</strong></p>
<p>​        在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，JVM（Java 虚拟机）让其持有偏向锁，并将  threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否尤其线程 id  一致，如果一致则可以直接使用，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，不会阻塞，执行一定次数之后就会升级为重量级锁，进入阻塞，整个过程就是锁升级的过程。</p>
<h1 id="并发包中的高级同步工具"><a href="#并发包中的高级同步工具" class="headerlink" title="并发包中的高级同步工具"></a>并发包中的高级同步工具</h1><p>java.utils.concurrent (JUC)</p>
<ul>
<li>提供了线程池的创建类ThreadPoolExecutor，Executors等；</li>
<li>提供了各种锁，如Lock，ReentrantLock等；</li>
<li>提供了各种线程安全的数据结构，如ConcurrentHashMap，LinkedBlockingQueue等；</li>
<li>提供了更加高级的线程同步结构，如CountDownLatch、CyclicBarrier、Semaphore 等。</li>
</ul>
<p><strong>CountDownLatch</strong></p>
<p>​        CountDownLatch(闭锁)可以看作一个只能做减法的计数器，可以让一个或多个线程等待执行。</p>
<p>​        两个重要的方法：</p>
<ul>
<li>countDown()：使计数器减1；</li>
<li>await()：当计数器不为0时，则调用该方法的线程阻塞，当计数器为0时，唤醒等待的一个或多个线程。</li>
</ul>
<p><strong>CyclicBarrier</strong></p>
<p>​        CyclicBarrier（循环屏障）通过它可以实现一组线程等待满足某个条件后同时进行。</p>
<p>​        它的构造方法为 <code>CyclicBarrier(int parties,Runnable barrierAction)</code>  其中，parties 表示有几个线程来参与等待，barrierAction 表示满足条件之后触发的方法。CyclicBarrier 使用 await() 方法来标识当前线程已到达屏障点，然后被阻塞。</p>
<p>**Semaphore **</p>
<p>​        Semaphore （信号量）用于管理多线程中控制资源的访问与使用。</p>
<p>​        Semaphore 就好比停车场的门卫，可以控制车位的使用资源。比如来了 5 辆车，只有 2 个车位，门卫可以先放两辆车进去，等有车出来之后，再让后面的车进入。</p>
<p><strong>Phaser</strong></p>
<p>​        Phaser(移加器)是JDK 7 提供的，它的功能是等待所有线程到达之后，才继续或者开始进行新的一组任务。</p>
<h1 id="锁和CAS"><a href="#锁和CAS" class="headerlink" title="锁和CAS"></a>锁和CAS</h1><p>​        <strong>乐观锁和悲观锁</strong></p>
<p>​        乐观锁和悲观锁不是具体的“锁”，而是一种并发编程的基本概念。最早出现在数据库的设计中，后来逐渐倍Java的并发包所引入。</p>
<ul>
<li><p>悲观锁</p>
<p>​    悲观锁认为对于同一个数据的并发操作，一定会发生修改，哪怕没有被修改，也会认为被修改了。因此对于同一个数据的并发操作，悲观锁采取加锁的形式，悲观的认为，不加锁的并发操作一定会出问题。</p>
</li>
<li><p>乐观锁</p>
<p>​    乐观锁在获取数据时，并不担心数据被修改，每次获取数据时也不会加锁，只是在更新时，通过判断现有的数据是否和原数据一致来判断数据是否被其他线程操作，如果没被其他线程修改，则不进行数据更新，如果被其他线程修改则进行数据更新。</p>
</li>
</ul>
<p><strong>公平锁和非公平锁</strong></p>
<p>​        根据线程获取锁的抢占机制，分为公平锁和非公平锁。</p>
<ul>
<li><p>公平锁</p>
<p>​    公平锁是指多个线程按照申请锁的顺序来获取锁。</p>
</li>
<li><p>非公平锁</p>
<p>​    非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，而是通过抢占的方式去获取锁。</p>
<p>​    ReentrantLock提供了创建两种锁的方式：</p>
<p>new ReentrantLock(true/false);    // 公平锁/非公平锁</p>
<p>​    如果构造函数不传入参数，默认为非公平锁。</p>
</li>
</ul>
<p><strong>独占锁和共享锁</strong></p>
<p>​        根据锁能否被多个线程持有，可以分为独占锁和共享锁。</p>
<ul>
<li><p>独占锁</p>
<p>​    独占锁是指任何时候都只能有一个线程能执行资源操作。</p>
</li>
<li><p>共享锁</p>
<p>​    共享锁是指可以同时被多个线程读取，但只能被一个线程修改。比如ReentrantReadWriteLock就是共享锁的实现方式，它允许一个线程进行写操作，其他线程进行读操作。</p>
</li>
</ul>
<p><strong>可重入锁</strong></p>
<p>​        可重入锁指的是该线程获取了该锁之后，可以无限次的进入该锁锁住的代码。</p>
<p><strong>自旋锁</strong></p>
<p>​        自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去获取锁，这样的好处是减少线程上下文切换的损耗，缺点是会消耗CPU。</p>
<p><strong>偏向锁</strong></p>
<p>​        偏向锁会偏向于第一个获得它的线程。为了让线程获得锁的代价更低。</p>
<p><strong>MySQL间隙锁</strong></p>
<p>​        间隙锁是一个在索引记录之间的间隙上的锁。是innodb在可重复度提交下为了解决幻读问题引入的锁机制。它是为了保证在某个间隙下的数据在锁定情况下不会发生任何变化。</p>
<p><strong>CAS和ABA</strong></p>
<p>​        CAS(Compare and Swap)比较并交换，是一种乐观锁的实现，是用非阻塞算法来代替锁定，java.utils.concurrent包下的AtomicInteger 就是借助CAS来实现的。</p>
<p>​        著名的ABA问题就是CAS引起的。</p>
<p>​        线程A查询过一个数据为100，线程B在线程A下一次查询之前+50 -50，线程A查询结果还是100，觉得数据没有改变。</p>
<p>​        ABA问题描述：</p>
<ul>
<li><p>线程一：取款，获取原值 200 元，与 200 元比对成功，减去 100 元，修改结果为 100 元。</p>
</li>
<li><p>线程二：取款，获取原值 200 元，阻塞等待修改。</p>
</li>
<li><p>线程三：转账，获取原值 100 元，与 100 元比对成功，加上 100 元，修改结果为 200 元。</p>
</li>
<li><p>线程二：取款，恢复执行，原值为 200 元，与 200 元对比成功，减去 100 元，修改结果为 100 元。</p>
<p>​    常见解决ABA的方式：加版本号，来区分值是否有变动。</p>
<p>​    Java 1.5 提供了AtomicStampedReference原子引用变量，通过添加版本号解决ABA问题。</p>
</li>
</ul>
<hr>
<p><strong>synchronized是哪种锁的实现？为什么？</strong></p>
<p>​        synchronized是悲观锁的实现。因为synchronized修饰的代码，每次执行时都会进行加锁操作，同时只允许一个线程进行操作。</p>
<p><strong>synchronized是公平锁还是非公平锁？</strong></p>
<p>​        synchronized使用的是非公平锁，并且不可设置。这是因为非公平锁的吞吐量大于公平锁，并且是主流操作系统线程调度的基本选择。</p>
<p><strong>为什么非公平锁的吞吐量大于公平锁？</strong></p>
<p>​        比如A占用锁，B等待被唤醒，这时C来申请锁，如果是公平锁C就要排在B后面，但是非公平锁可以让C先用，当B被唤醒之前C就已近使用完成了，从而减少了C等待和唤醒之间的消耗。</p>
<p><strong>volatile的作用？</strong></p>
<p>​        volatile是JVM提供的最轻量级同步机制。</p>
<p>​        当变量被定义成volatile之后，具备两种特性：</p>
<ul>
<li><p>保证此变量对所有线程的可见性，当一条线程修改了这个变量的值，改的新值对于其他线程是可见的。（可以立即得知）</p>
</li>
<li><p>禁止指令重排序优化，普通变量仅仅能保证在该方法执行过程中正确结果，但是不保证程序代码的执行顺序。</p>
</li>
</ul>
<p><strong>volatile和synchronized的区别</strong></p>
<p>​    synchronized既能保证可见性，又能保证原子性。而volatile只能保证可见性，无法保证原子性。比如i++是volatile修饰会有线程安全的问题。</p>
<p><strong>CAS如何实现？</strong></p>
<p>​        通过Java Native Interface的代码实现，比如在windows系统CAS就是借助C语言来调用CPU底层指令实现的。</p>
<p>​        </p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">kilig</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://kilig98.github.io/2020/08/24/Java%E6%80%BB%E7%BB%932/">https://kilig98.github.io/2020/08/24/Java%E6%80%BB%E7%BB%932/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">kilig</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%80%BB%E7%BB%93/">
                                    <span class="chip bg-color">总结</span>
                                </a>
                            
                                <a href="/tags/JAVA/">
                                    <span class="chip bg-color">JAVA</span>
                                </a>
                            
                                <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">笔记</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/08/28/Java%E6%80%BB%E7%BB%933/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="Java总结3">
                        
                        <span class="card-title">Java总结3</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Spring 核心功能​        发展过程：

Spring1.x
​        此版本为了解决企业应用程序复杂性而创建的，当时J2EE应用的经典架构为分层架构：表现层，业务层，持久层。最流行的组合是SSH（Structs，Spr
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-08-28
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JAVA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" class="post-category">
                                    JAVA基本知识
                                </a>
                            
                            <a href="/categories/JAVA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/JAVA%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    JAVA学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%BB%E7%BB%93/">
                        <span class="chip bg-color">总结</span>
                    </a>
                    
                    <a href="/tags/JAVA/">
                        <span class="chip bg-color">JAVA</span>
                    </a>
                    
                    <a href="/tags/%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">笔记</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/08/18/Java%E6%80%BB%E7%BB%93/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="Java总结">
                        
                        <span class="card-title">Java总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
Java程序是怎么运行的？Q/A:  JDK和Java的区别？
​        JDK是Java开发工具包，里面包括：JRE（Java运行环境），JVM（Java虚拟机）等。
​        Java是一种开发语言。
Q/A:  Ja
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-08-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JAVA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" class="post-category">
                                    JAVA基本知识
                                </a>
                            
                            <a href="/categories/JAVA%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/JAVA%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    JAVA学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%80%BB%E7%BB%93/">
                        <span class="chip bg-color">总结</span>
                    </a>
                    
                    <a href="/tags/JAVA/">
                        <span class="chip bg-color">JAVA</span>
                    </a>
                    
                    <a href="/tags/%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">笔记</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="410983119"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">kilig</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">86.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "4";
                    var startDate = "23";
                    var startHour = "13";
                    var startMinute = "56";
                    var startSecond = "4";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">














</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
